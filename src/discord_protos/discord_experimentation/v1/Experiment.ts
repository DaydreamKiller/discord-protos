// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "discord_experimentation/v1/Experiment.proto" (package "discord_protos.discord_experimentation.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { UInt64Value } from "../../google/protobuf/wrappers";
import { UInt32Value } from "../../google/protobuf/wrappers";
import { StringValue } from "../../google/protobuf/wrappers";
import { Timestamp } from "../../google/protobuf/timestamp";
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment
 */
export interface Experiment {
    /**
     * @generated from protobuf field: fixed64 id = 1
     */
    id: bigint;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp created_at = 3
     */
    createdAt?: Timestamp;
    /**
     * @generated from protobuf field: fixed64 creator_id = 4
     */
    creatorId: bigint;
    /**
     * @generated from protobuf field: int32 version = 5
     */
    version: number;
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp edited_at = 6
     */
    editedAt?: Timestamp;
    /**
     * @generated from protobuf field: fixed64 editor_id = 7
     */
    editorId: bigint;
    /**
     * @generated from protobuf field: string title = 8
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 9
     */
    description: string;
    /**
     * @generated from protobuf field: optional google.protobuf.StringValue hypothesis = 10
     */
    hypothesis?: StringValue;
    /**
     * @generated from protobuf field: optional google.protobuf.StringValue tech_spec_link = 11
     */
    techSpecLink?: StringValue;
    /**
     * @generated from protobuf field: int32 revision = 12
     */
    revision: number;
    /**
     * @generated from protobuf field: string hash_key = 13
     */
    hashKey: string;
    /**
     * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UnitType unit_type = 14
     */
    unitType: Experiment_UnitType;
    /**
     * @generated from protobuf field: repeated discord_protos.discord_experimentation.v1.Experiment.Variant variants = 15
     */
    variants: Experiment_Variant[];
    /**
     * @generated from protobuf field: repeated discord_protos.discord_experimentation.v1.Experiment.Rule rules = 16
     */
    rules: Experiment_Rule[];
    /**
     * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.Status status = 18
     */
    status: Experiment_Status;
    /**
     * @generated from protobuf field: repeated discord_protos.discord_experimentation.v1.Experiment.Surface surfaces = 19
     */
    surfaces: Experiment_Surface[];
    /**
     * @generated from protobuf field: string owning_team_name = 20
     */
    owningTeamName: string;
    /**
     * @generated from protobuf field: fixed64 cached_notification_channel_id = 21
     */
    cachedNotificationChannelId: bigint;
    /**
     * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.ExposureTracking exposure_tracking = 22
     */
    exposureTracking: Experiment_ExposureTracking;
    /**
     * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.AssignmentMode assignment_mode = 25
     */
    assignmentMode: Experiment_AssignmentMode;
    /**
     * @generated from protobuf field: bool enable_edit_raw_json_ui = 23
     */
    enableEditRawJsonUi: boolean;
    /**
     * @generated from protobuf field: int32 winning_variant_id = 24
     */
    winningVariantId: number;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.VariantAllocation
 */
export interface Experiment_VariantAllocation {
    /**
     * @generated from protobuf field: int32 start = 1
     */
    start: number;
    /**
     * @generated from protobuf field: int32 stop = 2
     */
    stop: number;
    /**
     * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.Type type = 3
     */
    type: Experiment_Type;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.Variant
 */
export interface Experiment_Variant {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string label = 2
     */
    label: string;
    /**
     * @generated from protobuf field: repeated discord_protos.discord_experimentation.v1.Experiment.VariantAllocation allocations = 4
     */
    allocations: Experiment_VariantAllocation[];
    /**
     * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.Type type = 5
     */
    type: Experiment_Type;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.PlatformVersionSpecifier
 */
export interface Experiment_PlatformVersionSpecifier {
    /**
     * @generated from protobuf field: uint32 major = 1
     */
    major: number;
    /**
     * @generated from protobuf field: optional google.protobuf.UInt32Value minor = 2
     */
    minor?: UInt32Value;
    /**
     * @generated from protobuf field: optional google.protobuf.UInt64Value build = 3
     */
    build?: UInt64Value;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRangeBound
 */
export interface Experiment_PlatformVersionRangeBound {
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersionSpecifier version = 1
     */
    version?: Experiment_PlatformVersionSpecifier;
    /**
     * @generated from protobuf field: bool inclusive = 2
     */
    inclusive: boolean;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRange
 */
export interface Experiment_PlatformVersionRange {
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRangeBound lower_bound = 1
     */
    lowerBound?: Experiment_PlatformVersionRangeBound;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRangeBound upper_bound = 2
     */
    upperBound?: Experiment_PlatformVersionRangeBound;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.PlatformVersion
 */
export interface Experiment_PlatformVersion {
    /**
     * @generated from protobuf field: repeated discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRange ranges = 1
     */
    ranges: Experiment_PlatformVersionRange[];
    /**
     * @generated from protobuf field: bool work_around_pyoto_bug = 2
     */
    workAroundPyotoBug: boolean;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientPlatform
 */
export interface Experiment_ClientPlatform {
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion ios_version = 1
     */
    iosVersion?: Experiment_PlatformVersion;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion android_version = 2
     */
    androidVersion?: Experiment_PlatformVersion;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion web_version = 3
     */
    webVersion?: Experiment_PlatformVersion;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion native_version = 4
     */
    nativeVersion?: Experiment_PlatformVersion;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.SDKVersionSpecifier
 */
export interface Experiment_SDKVersionSpecifier {
    /**
     * @generated from protobuf field: int32 version = 1
     */
    version: number;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.SDKVersionRangeBound
 */
export interface Experiment_SDKVersionRangeBound {
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersionSpecifier version = 1
     */
    version?: Experiment_SDKVersionSpecifier;
    /**
     * @generated from protobuf field: bool inclusive = 2
     */
    inclusive: boolean;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.SDKVersionRange
 */
export interface Experiment_SDKVersionRange {
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersionRangeBound lower_bound = 1
     */
    lowerBound?: Experiment_SDKVersionRangeBound;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersionRangeBound upper_bound = 2
     */
    upperBound?: Experiment_SDKVersionRangeBound;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.SDKVersion
 */
export interface Experiment_SDKVersion {
    /**
     * @generated from protobuf field: repeated discord_protos.discord_experimentation.v1.Experiment.SDKVersionRange ranges = 1
     */
    ranges: Experiment_SDKVersionRange[];
    /**
     * @generated from protobuf field: bool work_around_pyoto_bug = 2
     */
    workAroundPyotoBug: boolean;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientOperatingSystem
 */
export interface Experiment_ClientOperatingSystem {
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion ios_version = 1
     */
    iosVersion?: Experiment_SDKVersion;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion android_version = 2
     */
    androidVersion?: Experiment_SDKVersion;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion macos_version = 3
     */
    macosVersion?: Experiment_SDKVersion;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion windows_version = 4
     */
    windowsVersion?: Experiment_SDKVersion;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion playstation_version = 5
     */
    playstationVersion?: Experiment_SDKVersion;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion xbox_version = 6
     */
    xboxVersion?: Experiment_SDKVersion;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion linux_version = 7
     */
    linuxVersion?: Experiment_SDKVersion;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.StaffUsers
 */
export interface Experiment_StaffUsers {
    /**
     * @generated from protobuf field: bool work_accounts = 1
     */
    workAccounts: boolean;
    /**
     * @generated from protobuf field: bool personal_accounts = 2
     */
    personalAccounts: boolean;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UserInGuild
 */
export interface Experiment_UserInGuild {
    /**
     * @generated from protobuf field: repeated fixed64 guild_ids = 1
     */
    guildIds: bigint[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UserIds
 */
export interface Experiment_UserIds {
    /**
     * @generated from protobuf field: repeated fixed64 user_ids = 1
     */
    userIds: bigint[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientLocale
 */
export interface Experiment_ClientLocale {
    /**
     * @generated from protobuf field: repeated string locales = 1 [packed = false]
     */
    locales: string[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.ISORegion
 */
export interface Experiment_ISORegion {
    /**
     * @generated from protobuf field: string iso_country = 1
     */
    isoCountry: string;
    /**
     * @generated from protobuf field: string iso_subdivision = 2
     */
    isoSubdivision: string;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.Place
 */
export interface Experiment_Place {
    /**
     * @generated from protobuf field: string city = 1
     */
    city: string;
    /**
     * @generated from protobuf field: string subdivision = 2
     */
    subdivision: string;
    /**
     * @generated from protobuf field: string country = 3
     */
    country: string;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.Location
 */
export interface Experiment_Location {
    /**
     * @generated from protobuf oneof: location
     */
    location: {
        oneofKind: "isoRegion";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.ISORegion iso_region = 1
         */
        isoRegion: Experiment_ISORegion;
    } | {
        oneofKind: "isEu";
        /**
         * @generated from protobuf field: bool is_eu = 2
         */
        isEu: boolean;
    } | {
        oneofKind: "place";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.Place place = 3
         */
        place: Experiment_Place;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientLocation
 */
export interface Experiment_ClientLocation {
    /**
     * @generated from protobuf field: repeated discord_protos.discord_experimentation.v1.Experiment.Location locations = 1
     */
    locations: Experiment_Location[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientIP
 */
export interface Experiment_ClientIP {
    /**
     * @generated from protobuf field: repeated string blocks = 1 [packed = false]
     */
    blocks: string[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UserLocale
 */
export interface Experiment_UserLocale {
    /**
     * @generated from protobuf field: repeated string locales = 1 [packed = false]
     */
    locales: string[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UserIsBot
 */
export interface Experiment_UserIsBot {
    /**
     * @generated from protobuf field: bool is_bot = 1
     */
    isBot: boolean;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UserAgeRange
 */
export interface Experiment_UserAgeRange {
    /**
     * @generated from protobuf field: optional google.protobuf.UInt32Value min_age_years = 1
     */
    minAgeYears?: UInt32Value;
    /**
     * @generated from protobuf field: optional google.protobuf.UInt32Value max_age_years = 2
     */
    maxAgeYears?: UInt32Value;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.Fixed64Value
 */
export interface Experiment_Fixed64Value {
    /**
     * @generated from protobuf field: fixed64 value = 1
     */
    value: bigint;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UserIDRange
 */
export interface Experiment_UserIDRange {
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.Fixed64Value min_id = 1
     */
    minId?: Experiment_Fixed64Value;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.Fixed64Value max_id = 2
     */
    maxId?: Experiment_Fixed64Value;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UserHasFlag
 */
export interface Experiment_UserHasFlag {
    /**
     * @generated from protobuf field: fixed64 mask = 1
     */
    mask: bigint;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UnitIdInRangeByHash
 */
export interface Experiment_UnitIdInRangeByHash {
    /**
     * @generated from protobuf field: string hash_key = 1
     */
    hashKey: string;
    /**
     * @generated from protobuf field: uint32 target = 2
     */
    target: number;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientReleaseChannel
 */
export interface Experiment_ClientReleaseChannel {
    /**
     * @generated from protobuf field: repeated string release_channels = 1 [packed = false]
     */
    releaseChannels: string[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.Always
 */
export interface Experiment_Always {
    /**
     * @generated from protobuf field: bool value = 1
     */
    value: boolean;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.Filter
 */
export interface Experiment_Filter {
    /**
     * @generated from protobuf oneof: filter
     */
    filter: {
        oneofKind: "clientVersion";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.ClientPlatform client_version = 2
         */
        clientVersion: Experiment_ClientPlatform;
    } | {
        oneofKind: "clientOs";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.ClientOperatingSystem client_os = 3
         */
        clientOs: Experiment_ClientOperatingSystem;
    } | {
        oneofKind: "staff";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.StaffUsers staff = 4
         */
        staff: Experiment_StaffUsers;
    } | {
        oneofKind: "userInGuild";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UserInGuild user_in_guild = 5
         */
        userInGuild: Experiment_UserInGuild;
    } | {
        oneofKind: "userIds";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UserIds user_ids = 6
         */
        userIds: Experiment_UserIds;
    } | {
        oneofKind: "clientLocale";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.ClientLocale client_locale = 7
         */
        clientLocale: Experiment_ClientLocale;
    } | {
        oneofKind: "clientLocation";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.ClientLocation client_location = 8
         */
        clientLocation: Experiment_ClientLocation;
    } | {
        oneofKind: "clientIp";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.ClientIP client_ip = 9
         */
        clientIp: Experiment_ClientIP;
    } | {
        oneofKind: "userLocale";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UserLocale user_locale = 10
         */
        userLocale: Experiment_UserLocale;
    } | {
        oneofKind: "bot";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UserIsBot bot = 11
         */
        bot: Experiment_UserIsBot;
    } | {
        oneofKind: "userAgeRange";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UserAgeRange user_age_range = 12
         */
        userAgeRange: Experiment_UserAgeRange;
    } | {
        oneofKind: "userIdRange";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UserIDRange user_id_range = 13
         */
        userIdRange: Experiment_UserIDRange;
    } | {
        oneofKind: "userHasFlag";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UserHasFlag user_has_flag = 14
         */
        userHasFlag: Experiment_UserHasFlag;
    } | {
        oneofKind: "unitIdInRangeByHash";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UnitIdInRangeByHash unit_id_in_range_by_hash = 15
         */
        unitIdInRangeByHash: Experiment_UnitIdInRangeByHash;
    } | {
        oneofKind: "clientReleaseChannel";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.ClientReleaseChannel client_release_channel = 16
         */
        clientReleaseChannel: Experiment_ClientReleaseChannel;
    } | {
        oneofKind: "always";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.Always always = 17
         */
        always: Experiment_Always;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.Override
 */
export interface Experiment_Override {
    /**
     * @generated from protobuf field: int32 variant_id = 1
     */
    variantId: number;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.Rule
 */
export interface Experiment_Rule {
    /**
     * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.Type type = 1
     */
    type: Experiment_Type;
    /**
     * @generated from protobuf field: repeated discord_protos.discord_experimentation.v1.Experiment.Filter filters = 2
     */
    filters: Experiment_Filter[];
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.Override override = 3
     */
    override?: Experiment_Override;
    /**
     * @generated from protobuf field: bool is_sunset_rule = 4
     */
    isSunsetRule: boolean;
}
/**
 * @generated from protobuf enum discord_protos.discord_experimentation.v1.Experiment.UnitType
 */
export enum Experiment_UnitType {
    /**
     * @generated from protobuf enum value: UNIT_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: UNIT_TYPE_USER = 1;
     */
    USER = 1
}
/**
 * @generated from protobuf enum discord_protos.discord_experimentation.v1.Experiment.Type
 */
export enum Experiment_Type {
    /**
     * @generated from protobuf enum value: TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: TYPE_ACTIVE = 1;
     */
    ACTIVE = 1,
    /**
     * @generated from protobuf enum value: TYPE_UNUSED = 2;
     */
    UNUSED = 2,
    /**
     * @generated from protobuf enum value: TYPE_BURNED = 3;
     */
    BURNED = 3
}
/**
 * @generated from protobuf enum discord_protos.discord_experimentation.v1.Experiment.Status
 */
export enum Experiment_Status {
    /**
     * @generated from protobuf enum value: STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: STATUS_DRAFT = 1;
     */
    DRAFT = 1,
    /**
     * @generated from protobuf enum value: STATUS_TESTING = 2;
     */
    TESTING = 2,
    /**
     * @generated from protobuf enum value: STATUS_TESTING_ENDED = 3;
     */
    TESTING_ENDED = 3,
    /**
     * @generated from protobuf enum value: STATUS_ROLLING_OUT = 4;
     */
    ROLLING_OUT = 4,
    /**
     * @generated from protobuf enum value: STATUS_ROLLED_OUT = 5;
     */
    ROLLED_OUT = 5,
    /**
     * @generated from protobuf enum value: STATUS_ARCHIVED = 6;
     */
    ARCHIVED = 6
}
/**
 * @generated from protobuf enum discord_protos.discord_experimentation.v1.Experiment.Surface
 */
export enum Experiment_Surface {
    /**
     * @generated from protobuf enum value: SURFACE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SURFACE_API = 1;
     */
    API = 1,
    /**
     * @generated from protobuf enum value: SURFACE_APP = 2;
     */
    APP = 2
}
/**
 * @generated from protobuf enum discord_protos.discord_experimentation.v1.Experiment.ExposureTracking
 */
export enum Experiment_ExposureTracking {
    /**
     * @generated from protobuf enum value: EXPOSURE_TRACKING_ENABLED = 0;
     */
    ENABLED = 0,
    /**
     * @generated from protobuf enum value: EXPOSURE_TRACKING_DISABLED = 1;
     */
    DISABLED = 1
}
/**
 * @generated from protobuf enum discord_protos.discord_experimentation.v1.Experiment.AssignmentMode
 */
export enum Experiment_AssignmentMode {
    /**
     * @generated from protobuf enum value: ASSIGNMENT_MODE_FULL = 0;
     */
    FULL = 0,
    /**
     * @generated from protobuf enum value: ASSIGNMENT_MODE_FORCE_DEFAULT = 1;
     */
    FORCE_DEFAULT = 1,
    /**
     * @generated from protobuf enum value: ASSIGNMENT_MODE_OVERRIDE_ONLY = 2;
     */
    OVERRIDE_ONLY = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Experiment$Type extends MessageType<Experiment> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment", [
            { no: 1, name: "id", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 4, name: "creator_id", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "version", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "edited_at", kind: "message", T: () => Timestamp },
            { no: 7, name: "editor_id", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "hypothesis", kind: "message", T: () => StringValue },
            { no: 11, name: "tech_spec_link", kind: "message", T: () => StringValue },
            { no: 12, name: "revision", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "hash_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "unit_type", kind: "enum", T: () => ["discord_protos.discord_experimentation.v1.Experiment.UnitType", Experiment_UnitType, "UNIT_TYPE_"] },
            { no: 15, name: "variants", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Experiment_Variant },
            { no: 16, name: "rules", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Experiment_Rule },
            { no: 18, name: "status", kind: "enum", T: () => ["discord_protos.discord_experimentation.v1.Experiment.Status", Experiment_Status, "STATUS_"] },
            { no: 19, name: "surfaces", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["discord_protos.discord_experimentation.v1.Experiment.Surface", Experiment_Surface, "SURFACE_"] },
            { no: 20, name: "owning_team_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "cached_notification_channel_id", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 22, name: "exposure_tracking", kind: "enum", T: () => ["discord_protos.discord_experimentation.v1.Experiment.ExposureTracking", Experiment_ExposureTracking, "EXPOSURE_TRACKING_"] },
            { no: 25, name: "assignment_mode", kind: "enum", T: () => ["discord_protos.discord_experimentation.v1.Experiment.AssignmentMode", Experiment_AssignmentMode, "ASSIGNMENT_MODE_"] },
            { no: 23, name: "enable_edit_raw_json_ui", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "winning_variant_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment>): Experiment {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.name = "";
        message.creatorId = 0n;
        message.version = 0;
        message.editorId = 0n;
        message.title = "";
        message.description = "";
        message.revision = 0;
        message.hashKey = "";
        message.unitType = 0;
        message.variants = [];
        message.rules = [];
        message.status = 0;
        message.surfaces = [];
        message.owningTeamName = "";
        message.cachedNotificationChannelId = 0n;
        message.exposureTracking = 0;
        message.assignmentMode = 0;
        message.enableEditRawJsonUi = false;
        message.winningVariantId = 0;
        if (value !== undefined)
            reflectionMergePartial<Experiment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment): Experiment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed64 id */ 1:
                    message.id = reader.fixed64().toBigInt();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional google.protobuf.Timestamp created_at */ 3:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* fixed64 creator_id */ 4:
                    message.creatorId = reader.fixed64().toBigInt();
                    break;
                case /* int32 version */ 5:
                    message.version = reader.int32();
                    break;
                case /* optional google.protobuf.Timestamp edited_at */ 6:
                    message.editedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.editedAt);
                    break;
                case /* fixed64 editor_id */ 7:
                    message.editorId = reader.fixed64().toBigInt();
                    break;
                case /* string title */ 8:
                    message.title = reader.string();
                    break;
                case /* string description */ 9:
                    message.description = reader.string();
                    break;
                case /* optional google.protobuf.StringValue hypothesis */ 10:
                    message.hypothesis = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.hypothesis);
                    break;
                case /* optional google.protobuf.StringValue tech_spec_link */ 11:
                    message.techSpecLink = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.techSpecLink);
                    break;
                case /* int32 revision */ 12:
                    message.revision = reader.int32();
                    break;
                case /* string hash_key */ 13:
                    message.hashKey = reader.string();
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UnitType unit_type */ 14:
                    message.unitType = reader.int32();
                    break;
                case /* repeated discord_protos.discord_experimentation.v1.Experiment.Variant variants */ 15:
                    message.variants.push(Experiment_Variant.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated discord_protos.discord_experimentation.v1.Experiment.Rule rules */ 16:
                    message.rules.push(Experiment_Rule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.Status status */ 18:
                    message.status = reader.int32();
                    break;
                case /* repeated discord_protos.discord_experimentation.v1.Experiment.Surface surfaces */ 19:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.surfaces.push(reader.int32());
                    else
                        message.surfaces.push(reader.int32());
                    break;
                case /* string owning_team_name */ 20:
                    message.owningTeamName = reader.string();
                    break;
                case /* fixed64 cached_notification_channel_id */ 21:
                    message.cachedNotificationChannelId = reader.fixed64().toBigInt();
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.ExposureTracking exposure_tracking */ 22:
                    message.exposureTracking = reader.int32();
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.AssignmentMode assignment_mode */ 25:
                    message.assignmentMode = reader.int32();
                    break;
                case /* bool enable_edit_raw_json_ui */ 23:
                    message.enableEditRawJsonUi = reader.bool();
                    break;
                case /* int32 winning_variant_id */ 24:
                    message.winningVariantId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Bit64).fixed64(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional google.protobuf.Timestamp created_at = 3; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* fixed64 creator_id = 4; */
        if (message.creatorId !== 0n)
            writer.tag(4, WireType.Bit64).fixed64(message.creatorId);
        /* int32 version = 5; */
        if (message.version !== 0)
            writer.tag(5, WireType.Varint).int32(message.version);
        /* optional google.protobuf.Timestamp edited_at = 6; */
        if (message.editedAt)
            Timestamp.internalBinaryWrite(message.editedAt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* fixed64 editor_id = 7; */
        if (message.editorId !== 0n)
            writer.tag(7, WireType.Bit64).fixed64(message.editorId);
        /* string title = 8; */
        if (message.title !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.title);
        /* string description = 9; */
        if (message.description !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.description);
        /* optional google.protobuf.StringValue hypothesis = 10; */
        if (message.hypothesis)
            StringValue.internalBinaryWrite(message.hypothesis, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.StringValue tech_spec_link = 11; */
        if (message.techSpecLink)
            StringValue.internalBinaryWrite(message.techSpecLink, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* int32 revision = 12; */
        if (message.revision !== 0)
            writer.tag(12, WireType.Varint).int32(message.revision);
        /* string hash_key = 13; */
        if (message.hashKey !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.hashKey);
        /* discord_protos.discord_experimentation.v1.Experiment.UnitType unit_type = 14; */
        if (message.unitType !== 0)
            writer.tag(14, WireType.Varint).int32(message.unitType);
        /* repeated discord_protos.discord_experimentation.v1.Experiment.Variant variants = 15; */
        for (let i = 0; i < message.variants.length; i++)
            Experiment_Variant.internalBinaryWrite(message.variants[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* repeated discord_protos.discord_experimentation.v1.Experiment.Rule rules = 16; */
        for (let i = 0; i < message.rules.length; i++)
            Experiment_Rule.internalBinaryWrite(message.rules[i], writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.Status status = 18; */
        if (message.status !== 0)
            writer.tag(18, WireType.Varint).int32(message.status);
        /* repeated discord_protos.discord_experimentation.v1.Experiment.Surface surfaces = 19; */
        if (message.surfaces.length) {
            writer.tag(19, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.surfaces.length; i++)
                writer.int32(message.surfaces[i]);
            writer.join();
        }
        /* string owning_team_name = 20; */
        if (message.owningTeamName !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.owningTeamName);
        /* fixed64 cached_notification_channel_id = 21; */
        if (message.cachedNotificationChannelId !== 0n)
            writer.tag(21, WireType.Bit64).fixed64(message.cachedNotificationChannelId);
        /* discord_protos.discord_experimentation.v1.Experiment.ExposureTracking exposure_tracking = 22; */
        if (message.exposureTracking !== 0)
            writer.tag(22, WireType.Varint).int32(message.exposureTracking);
        /* bool enable_edit_raw_json_ui = 23; */
        if (message.enableEditRawJsonUi !== false)
            writer.tag(23, WireType.Varint).bool(message.enableEditRawJsonUi);
        /* int32 winning_variant_id = 24; */
        if (message.winningVariantId !== 0)
            writer.tag(24, WireType.Varint).int32(message.winningVariantId);
        /* discord_protos.discord_experimentation.v1.Experiment.AssignmentMode assignment_mode = 25; */
        if (message.assignmentMode !== 0)
            writer.tag(25, WireType.Varint).int32(message.assignmentMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment
 */
export const Experiment = new Experiment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_VariantAllocation$Type extends MessageType<Experiment_VariantAllocation> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.VariantAllocation", [
            { no: 1, name: "start", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "stop", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "type", kind: "enum", T: () => ["discord_protos.discord_experimentation.v1.Experiment.Type", Experiment_Type, "TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<Experiment_VariantAllocation>): Experiment_VariantAllocation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.start = 0;
        message.stop = 0;
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<Experiment_VariantAllocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_VariantAllocation): Experiment_VariantAllocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 start */ 1:
                    message.start = reader.int32();
                    break;
                case /* int32 stop */ 2:
                    message.stop = reader.int32();
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.Type type */ 3:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_VariantAllocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 start = 1; */
        if (message.start !== 0)
            writer.tag(1, WireType.Varint).int32(message.start);
        /* int32 stop = 2; */
        if (message.stop !== 0)
            writer.tag(2, WireType.Varint).int32(message.stop);
        /* discord_protos.discord_experimentation.v1.Experiment.Type type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.VariantAllocation
 */
export const Experiment_VariantAllocation = new Experiment_VariantAllocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Variant$Type extends MessageType<Experiment_Variant> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.Variant", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "allocations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Experiment_VariantAllocation },
            { no: 5, name: "type", kind: "enum", T: () => ["discord_protos.discord_experimentation.v1.Experiment.Type", Experiment_Type, "TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<Experiment_Variant>): Experiment_Variant {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.label = "";
        message.allocations = [];
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<Experiment_Variant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Variant): Experiment_Variant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* repeated discord_protos.discord_experimentation.v1.Experiment.VariantAllocation allocations */ 4:
                    message.allocations.push(Experiment_VariantAllocation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.Type type */ 5:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Variant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* repeated discord_protos.discord_experimentation.v1.Experiment.VariantAllocation allocations = 4; */
        for (let i = 0; i < message.allocations.length; i++)
            Experiment_VariantAllocation.internalBinaryWrite(message.allocations[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.Type type = 5; */
        if (message.type !== 0)
            writer.tag(5, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.Variant
 */
export const Experiment_Variant = new Experiment_Variant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_PlatformVersionSpecifier$Type extends MessageType<Experiment_PlatformVersionSpecifier> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.PlatformVersionSpecifier", [
            { no: 1, name: "major", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "minor", kind: "message", T: () => UInt32Value },
            { no: 3, name: "build", kind: "message", T: () => UInt64Value }
        ]);
    }
    create(value?: PartialMessage<Experiment_PlatformVersionSpecifier>): Experiment_PlatformVersionSpecifier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.major = 0;
        if (value !== undefined)
            reflectionMergePartial<Experiment_PlatformVersionSpecifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_PlatformVersionSpecifier): Experiment_PlatformVersionSpecifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 major */ 1:
                    message.major = reader.uint32();
                    break;
                case /* optional google.protobuf.UInt32Value minor */ 2:
                    message.minor = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.minor);
                    break;
                case /* optional google.protobuf.UInt64Value build */ 3:
                    message.build = UInt64Value.internalBinaryRead(reader, reader.uint32(), options, message.build);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_PlatformVersionSpecifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 major = 1; */
        if (message.major !== 0)
            writer.tag(1, WireType.Varint).uint32(message.major);
        /* optional google.protobuf.UInt32Value minor = 2; */
        if (message.minor)
            UInt32Value.internalBinaryWrite(message.minor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.UInt64Value build = 3; */
        if (message.build)
            UInt64Value.internalBinaryWrite(message.build, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.PlatformVersionSpecifier
 */
export const Experiment_PlatformVersionSpecifier = new Experiment_PlatformVersionSpecifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_PlatformVersionRangeBound$Type extends MessageType<Experiment_PlatformVersionRangeBound> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRangeBound", [
            { no: 1, name: "version", kind: "message", T: () => Experiment_PlatformVersionSpecifier },
            { no: 2, name: "inclusive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_PlatformVersionRangeBound>): Experiment_PlatformVersionRangeBound {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.inclusive = false;
        if (value !== undefined)
            reflectionMergePartial<Experiment_PlatformVersionRangeBound>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_PlatformVersionRangeBound): Experiment_PlatformVersionRangeBound {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersionSpecifier version */ 1:
                    message.version = Experiment_PlatformVersionSpecifier.internalBinaryRead(reader, reader.uint32(), options, message.version);
                    break;
                case /* bool inclusive */ 2:
                    message.inclusive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_PlatformVersionRangeBound, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersionSpecifier version = 1; */
        if (message.version)
            Experiment_PlatformVersionSpecifier.internalBinaryWrite(message.version, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool inclusive = 2; */
        if (message.inclusive !== false)
            writer.tag(2, WireType.Varint).bool(message.inclusive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRangeBound
 */
export const Experiment_PlatformVersionRangeBound = new Experiment_PlatformVersionRangeBound$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_PlatformVersionRange$Type extends MessageType<Experiment_PlatformVersionRange> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRange", [
            { no: 1, name: "lower_bound", kind: "message", T: () => Experiment_PlatformVersionRangeBound },
            { no: 2, name: "upper_bound", kind: "message", T: () => Experiment_PlatformVersionRangeBound }
        ]);
    }
    create(value?: PartialMessage<Experiment_PlatformVersionRange>): Experiment_PlatformVersionRange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Experiment_PlatformVersionRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_PlatformVersionRange): Experiment_PlatformVersionRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRangeBound lower_bound */ 1:
                    message.lowerBound = Experiment_PlatformVersionRangeBound.internalBinaryRead(reader, reader.uint32(), options, message.lowerBound);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRangeBound upper_bound */ 2:
                    message.upperBound = Experiment_PlatformVersionRangeBound.internalBinaryRead(reader, reader.uint32(), options, message.upperBound);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_PlatformVersionRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRangeBound lower_bound = 1; */
        if (message.lowerBound)
            Experiment_PlatformVersionRangeBound.internalBinaryWrite(message.lowerBound, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRangeBound upper_bound = 2; */
        if (message.upperBound)
            Experiment_PlatformVersionRangeBound.internalBinaryWrite(message.upperBound, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRange
 */
export const Experiment_PlatformVersionRange = new Experiment_PlatformVersionRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_PlatformVersion$Type extends MessageType<Experiment_PlatformVersion> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.PlatformVersion", [
            { no: 1, name: "ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Experiment_PlatformVersionRange },
            { no: 2, name: "work_around_pyoto_bug", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_PlatformVersion>): Experiment_PlatformVersion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ranges = [];
        message.workAroundPyotoBug = false;
        if (value !== undefined)
            reflectionMergePartial<Experiment_PlatformVersion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_PlatformVersion): Experiment_PlatformVersion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRange ranges */ 1:
                    message.ranges.push(Experiment_PlatformVersionRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool work_around_pyoto_bug */ 2:
                    message.workAroundPyotoBug = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_PlatformVersion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRange ranges = 1; */
        for (let i = 0; i < message.ranges.length; i++)
            Experiment_PlatformVersionRange.internalBinaryWrite(message.ranges[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool work_around_pyoto_bug = 2; */
        if (message.workAroundPyotoBug !== false)
            writer.tag(2, WireType.Varint).bool(message.workAroundPyotoBug);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.PlatformVersion
 */
export const Experiment_PlatformVersion = new Experiment_PlatformVersion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_ClientPlatform$Type extends MessageType<Experiment_ClientPlatform> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.ClientPlatform", [
            { no: 1, name: "ios_version", kind: "message", T: () => Experiment_PlatformVersion },
            { no: 2, name: "android_version", kind: "message", T: () => Experiment_PlatformVersion },
            { no: 3, name: "web_version", kind: "message", T: () => Experiment_PlatformVersion },
            { no: 4, name: "native_version", kind: "message", T: () => Experiment_PlatformVersion }
        ]);
    }
    create(value?: PartialMessage<Experiment_ClientPlatform>): Experiment_ClientPlatform {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Experiment_ClientPlatform>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_ClientPlatform): Experiment_ClientPlatform {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion ios_version */ 1:
                    message.iosVersion = Experiment_PlatformVersion.internalBinaryRead(reader, reader.uint32(), options, message.iosVersion);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion android_version */ 2:
                    message.androidVersion = Experiment_PlatformVersion.internalBinaryRead(reader, reader.uint32(), options, message.androidVersion);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion web_version */ 3:
                    message.webVersion = Experiment_PlatformVersion.internalBinaryRead(reader, reader.uint32(), options, message.webVersion);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion native_version */ 4:
                    message.nativeVersion = Experiment_PlatformVersion.internalBinaryRead(reader, reader.uint32(), options, message.nativeVersion);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_ClientPlatform, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion ios_version = 1; */
        if (message.iosVersion)
            Experiment_PlatformVersion.internalBinaryWrite(message.iosVersion, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion android_version = 2; */
        if (message.androidVersion)
            Experiment_PlatformVersion.internalBinaryWrite(message.androidVersion, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion web_version = 3; */
        if (message.webVersion)
            Experiment_PlatformVersion.internalBinaryWrite(message.webVersion, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion native_version = 4; */
        if (message.nativeVersion)
            Experiment_PlatformVersion.internalBinaryWrite(message.nativeVersion, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientPlatform
 */
export const Experiment_ClientPlatform = new Experiment_ClientPlatform$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_SDKVersionSpecifier$Type extends MessageType<Experiment_SDKVersionSpecifier> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.SDKVersionSpecifier", [
            { no: 1, name: "version", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_SDKVersionSpecifier>): Experiment_SDKVersionSpecifier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = 0;
        if (value !== undefined)
            reflectionMergePartial<Experiment_SDKVersionSpecifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_SDKVersionSpecifier): Experiment_SDKVersionSpecifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 version */ 1:
                    message.version = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_SDKVersionSpecifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 version = 1; */
        if (message.version !== 0)
            writer.tag(1, WireType.Varint).int32(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.SDKVersionSpecifier
 */
export const Experiment_SDKVersionSpecifier = new Experiment_SDKVersionSpecifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_SDKVersionRangeBound$Type extends MessageType<Experiment_SDKVersionRangeBound> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.SDKVersionRangeBound", [
            { no: 1, name: "version", kind: "message", T: () => Experiment_SDKVersionSpecifier },
            { no: 2, name: "inclusive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_SDKVersionRangeBound>): Experiment_SDKVersionRangeBound {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.inclusive = false;
        if (value !== undefined)
            reflectionMergePartial<Experiment_SDKVersionRangeBound>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_SDKVersionRangeBound): Experiment_SDKVersionRangeBound {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersionSpecifier version */ 1:
                    message.version = Experiment_SDKVersionSpecifier.internalBinaryRead(reader, reader.uint32(), options, message.version);
                    break;
                case /* bool inclusive */ 2:
                    message.inclusive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_SDKVersionRangeBound, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersionSpecifier version = 1; */
        if (message.version)
            Experiment_SDKVersionSpecifier.internalBinaryWrite(message.version, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool inclusive = 2; */
        if (message.inclusive !== false)
            writer.tag(2, WireType.Varint).bool(message.inclusive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.SDKVersionRangeBound
 */
export const Experiment_SDKVersionRangeBound = new Experiment_SDKVersionRangeBound$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_SDKVersionRange$Type extends MessageType<Experiment_SDKVersionRange> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.SDKVersionRange", [
            { no: 1, name: "lower_bound", kind: "message", T: () => Experiment_SDKVersionRangeBound },
            { no: 2, name: "upper_bound", kind: "message", T: () => Experiment_SDKVersionRangeBound }
        ]);
    }
    create(value?: PartialMessage<Experiment_SDKVersionRange>): Experiment_SDKVersionRange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Experiment_SDKVersionRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_SDKVersionRange): Experiment_SDKVersionRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersionRangeBound lower_bound */ 1:
                    message.lowerBound = Experiment_SDKVersionRangeBound.internalBinaryRead(reader, reader.uint32(), options, message.lowerBound);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersionRangeBound upper_bound */ 2:
                    message.upperBound = Experiment_SDKVersionRangeBound.internalBinaryRead(reader, reader.uint32(), options, message.upperBound);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_SDKVersionRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersionRangeBound lower_bound = 1; */
        if (message.lowerBound)
            Experiment_SDKVersionRangeBound.internalBinaryWrite(message.lowerBound, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersionRangeBound upper_bound = 2; */
        if (message.upperBound)
            Experiment_SDKVersionRangeBound.internalBinaryWrite(message.upperBound, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.SDKVersionRange
 */
export const Experiment_SDKVersionRange = new Experiment_SDKVersionRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_SDKVersion$Type extends MessageType<Experiment_SDKVersion> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.SDKVersion", [
            { no: 1, name: "ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Experiment_SDKVersionRange },
            { no: 2, name: "work_around_pyoto_bug", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_SDKVersion>): Experiment_SDKVersion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ranges = [];
        message.workAroundPyotoBug = false;
        if (value !== undefined)
            reflectionMergePartial<Experiment_SDKVersion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_SDKVersion): Experiment_SDKVersion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated discord_protos.discord_experimentation.v1.Experiment.SDKVersionRange ranges */ 1:
                    message.ranges.push(Experiment_SDKVersionRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool work_around_pyoto_bug */ 2:
                    message.workAroundPyotoBug = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_SDKVersion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated discord_protos.discord_experimentation.v1.Experiment.SDKVersionRange ranges = 1; */
        for (let i = 0; i < message.ranges.length; i++)
            Experiment_SDKVersionRange.internalBinaryWrite(message.ranges[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool work_around_pyoto_bug = 2; */
        if (message.workAroundPyotoBug !== false)
            writer.tag(2, WireType.Varint).bool(message.workAroundPyotoBug);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.SDKVersion
 */
export const Experiment_SDKVersion = new Experiment_SDKVersion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_ClientOperatingSystem$Type extends MessageType<Experiment_ClientOperatingSystem> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.ClientOperatingSystem", [
            { no: 1, name: "ios_version", kind: "message", T: () => Experiment_SDKVersion },
            { no: 2, name: "android_version", kind: "message", T: () => Experiment_SDKVersion },
            { no: 3, name: "macos_version", kind: "message", T: () => Experiment_SDKVersion },
            { no: 4, name: "windows_version", kind: "message", T: () => Experiment_SDKVersion },
            { no: 5, name: "playstation_version", kind: "message", T: () => Experiment_SDKVersion },
            { no: 6, name: "xbox_version", kind: "message", T: () => Experiment_SDKVersion },
            { no: 7, name: "linux_version", kind: "message", T: () => Experiment_SDKVersion }
        ]);
    }
    create(value?: PartialMessage<Experiment_ClientOperatingSystem>): Experiment_ClientOperatingSystem {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Experiment_ClientOperatingSystem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_ClientOperatingSystem): Experiment_ClientOperatingSystem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion ios_version */ 1:
                    message.iosVersion = Experiment_SDKVersion.internalBinaryRead(reader, reader.uint32(), options, message.iosVersion);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion android_version */ 2:
                    message.androidVersion = Experiment_SDKVersion.internalBinaryRead(reader, reader.uint32(), options, message.androidVersion);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion macos_version */ 3:
                    message.macosVersion = Experiment_SDKVersion.internalBinaryRead(reader, reader.uint32(), options, message.macosVersion);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion windows_version */ 4:
                    message.windowsVersion = Experiment_SDKVersion.internalBinaryRead(reader, reader.uint32(), options, message.windowsVersion);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion playstation_version */ 5:
                    message.playstationVersion = Experiment_SDKVersion.internalBinaryRead(reader, reader.uint32(), options, message.playstationVersion);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion xbox_version */ 6:
                    message.xboxVersion = Experiment_SDKVersion.internalBinaryRead(reader, reader.uint32(), options, message.xboxVersion);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion linux_version */ 7:
                    message.linuxVersion = Experiment_SDKVersion.internalBinaryRead(reader, reader.uint32(), options, message.linuxVersion);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_ClientOperatingSystem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion ios_version = 1; */
        if (message.iosVersion)
            Experiment_SDKVersion.internalBinaryWrite(message.iosVersion, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion android_version = 2; */
        if (message.androidVersion)
            Experiment_SDKVersion.internalBinaryWrite(message.androidVersion, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion macos_version = 3; */
        if (message.macosVersion)
            Experiment_SDKVersion.internalBinaryWrite(message.macosVersion, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion windows_version = 4; */
        if (message.windowsVersion)
            Experiment_SDKVersion.internalBinaryWrite(message.windowsVersion, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion playstation_version = 5; */
        if (message.playstationVersion)
            Experiment_SDKVersion.internalBinaryWrite(message.playstationVersion, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion xbox_version = 6; */
        if (message.xboxVersion)
            Experiment_SDKVersion.internalBinaryWrite(message.xboxVersion, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion linux_version = 7; */
        if (message.linuxVersion)
            Experiment_SDKVersion.internalBinaryWrite(message.linuxVersion, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientOperatingSystem
 */
export const Experiment_ClientOperatingSystem = new Experiment_ClientOperatingSystem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_StaffUsers$Type extends MessageType<Experiment_StaffUsers> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.StaffUsers", [
            { no: 1, name: "work_accounts", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "personal_accounts", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_StaffUsers>): Experiment_StaffUsers {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workAccounts = false;
        message.personalAccounts = false;
        if (value !== undefined)
            reflectionMergePartial<Experiment_StaffUsers>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_StaffUsers): Experiment_StaffUsers {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool work_accounts */ 1:
                    message.workAccounts = reader.bool();
                    break;
                case /* bool personal_accounts */ 2:
                    message.personalAccounts = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_StaffUsers, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool work_accounts = 1; */
        if (message.workAccounts !== false)
            writer.tag(1, WireType.Varint).bool(message.workAccounts);
        /* bool personal_accounts = 2; */
        if (message.personalAccounts !== false)
            writer.tag(2, WireType.Varint).bool(message.personalAccounts);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.StaffUsers
 */
export const Experiment_StaffUsers = new Experiment_StaffUsers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UserInGuild$Type extends MessageType<Experiment_UserInGuild> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UserInGuild", [
            { no: 1, name: "guild_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_UserInGuild>): Experiment_UserInGuild {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.guildIds = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_UserInGuild>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UserInGuild): Experiment_UserInGuild {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed64 guild_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.guildIds.push(reader.fixed64().toBigInt());
                    else
                        message.guildIds.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UserInGuild, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed64 guild_ids = 1; */
        if (message.guildIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.guildIds.length; i++)
                writer.fixed64(message.guildIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UserInGuild
 */
export const Experiment_UserInGuild = new Experiment_UserInGuild$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UserIds$Type extends MessageType<Experiment_UserIds> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UserIds", [
            { no: 1, name: "user_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_UserIds>): Experiment_UserIds {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userIds = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_UserIds>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UserIds): Experiment_UserIds {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed64 user_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.userIds.push(reader.fixed64().toBigInt());
                    else
                        message.userIds.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UserIds, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed64 user_ids = 1; */
        if (message.userIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.userIds.length; i++)
                writer.fixed64(message.userIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UserIds
 */
export const Experiment_UserIds = new Experiment_UserIds$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_ClientLocale$Type extends MessageType<Experiment_ClientLocale> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.ClientLocale", [
            { no: 1, name: "locales", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_ClientLocale>): Experiment_ClientLocale {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.locales = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_ClientLocale>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_ClientLocale): Experiment_ClientLocale {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string locales = 1 [packed = false] */ 1:
                    message.locales.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_ClientLocale, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string locales = 1 [packed = false]; */
        for (let i = 0; i < message.locales.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.locales[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientLocale
 */
export const Experiment_ClientLocale = new Experiment_ClientLocale$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_ISORegion$Type extends MessageType<Experiment_ISORegion> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.ISORegion", [
            { no: 1, name: "iso_country", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "iso_subdivision", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_ISORegion>): Experiment_ISORegion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isoCountry = "";
        message.isoSubdivision = "";
        if (value !== undefined)
            reflectionMergePartial<Experiment_ISORegion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_ISORegion): Experiment_ISORegion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string iso_country */ 1:
                    message.isoCountry = reader.string();
                    break;
                case /* string iso_subdivision */ 2:
                    message.isoSubdivision = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_ISORegion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string iso_country = 1; */
        if (message.isoCountry !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.isoCountry);
        /* string iso_subdivision = 2; */
        if (message.isoSubdivision !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.isoSubdivision);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.ISORegion
 */
export const Experiment_ISORegion = new Experiment_ISORegion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Place$Type extends MessageType<Experiment_Place> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.Place", [
            { no: 1, name: "city", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subdivision", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "country", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_Place>): Experiment_Place {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.city = "";
        message.subdivision = "";
        message.country = "";
        if (value !== undefined)
            reflectionMergePartial<Experiment_Place>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Place): Experiment_Place {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string city */ 1:
                    message.city = reader.string();
                    break;
                case /* string subdivision */ 2:
                    message.subdivision = reader.string();
                    break;
                case /* string country */ 3:
                    message.country = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Place, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string city = 1; */
        if (message.city !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.city);
        /* string subdivision = 2; */
        if (message.subdivision !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subdivision);
        /* string country = 3; */
        if (message.country !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.country);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.Place
 */
export const Experiment_Place = new Experiment_Place$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Location$Type extends MessageType<Experiment_Location> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.Location", [
            { no: 1, name: "iso_region", kind: "message", oneof: "location", T: () => Experiment_ISORegion },
            { no: 2, name: "is_eu", kind: "scalar", oneof: "location", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "place", kind: "message", oneof: "location", T: () => Experiment_Place }
        ]);
    }
    create(value?: PartialMessage<Experiment_Location>): Experiment_Location {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.location = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Experiment_Location>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Location): Experiment_Location {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* discord_protos.discord_experimentation.v1.Experiment.ISORegion iso_region */ 1:
                    message.location = {
                        oneofKind: "isoRegion",
                        isoRegion: Experiment_ISORegion.internalBinaryRead(reader, reader.uint32(), options, (message.location as any).isoRegion)
                    };
                    break;
                case /* bool is_eu */ 2:
                    message.location = {
                        oneofKind: "isEu",
                        isEu: reader.bool()
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.Place place */ 3:
                    message.location = {
                        oneofKind: "place",
                        place: Experiment_Place.internalBinaryRead(reader, reader.uint32(), options, (message.location as any).place)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Location, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* discord_protos.discord_experimentation.v1.Experiment.ISORegion iso_region = 1; */
        if (message.location.oneofKind === "isoRegion")
            Experiment_ISORegion.internalBinaryWrite(message.location.isoRegion, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool is_eu = 2; */
        if (message.location.oneofKind === "isEu")
            writer.tag(2, WireType.Varint).bool(message.location.isEu);
        /* discord_protos.discord_experimentation.v1.Experiment.Place place = 3; */
        if (message.location.oneofKind === "place")
            Experiment_Place.internalBinaryWrite(message.location.place, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.Location
 */
export const Experiment_Location = new Experiment_Location$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_ClientLocation$Type extends MessageType<Experiment_ClientLocation> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.ClientLocation", [
            { no: 1, name: "locations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Experiment_Location }
        ]);
    }
    create(value?: PartialMessage<Experiment_ClientLocation>): Experiment_ClientLocation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.locations = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_ClientLocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_ClientLocation): Experiment_ClientLocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated discord_protos.discord_experimentation.v1.Experiment.Location locations */ 1:
                    message.locations.push(Experiment_Location.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_ClientLocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated discord_protos.discord_experimentation.v1.Experiment.Location locations = 1; */
        for (let i = 0; i < message.locations.length; i++)
            Experiment_Location.internalBinaryWrite(message.locations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientLocation
 */
export const Experiment_ClientLocation = new Experiment_ClientLocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_ClientIP$Type extends MessageType<Experiment_ClientIP> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.ClientIP", [
            { no: 1, name: "blocks", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_ClientIP>): Experiment_ClientIP {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.blocks = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_ClientIP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_ClientIP): Experiment_ClientIP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string blocks = 1 [packed = false] */ 1:
                    message.blocks.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_ClientIP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string blocks = 1 [packed = false]; */
        for (let i = 0; i < message.blocks.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.blocks[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientIP
 */
export const Experiment_ClientIP = new Experiment_ClientIP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UserLocale$Type extends MessageType<Experiment_UserLocale> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UserLocale", [
            { no: 1, name: "locales", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_UserLocale>): Experiment_UserLocale {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.locales = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_UserLocale>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UserLocale): Experiment_UserLocale {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string locales = 1 [packed = false] */ 1:
                    message.locales.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UserLocale, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string locales = 1 [packed = false]; */
        for (let i = 0; i < message.locales.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.locales[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UserLocale
 */
export const Experiment_UserLocale = new Experiment_UserLocale$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UserIsBot$Type extends MessageType<Experiment_UserIsBot> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UserIsBot", [
            { no: 1, name: "is_bot", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_UserIsBot>): Experiment_UserIsBot {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isBot = false;
        if (value !== undefined)
            reflectionMergePartial<Experiment_UserIsBot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UserIsBot): Experiment_UserIsBot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_bot */ 1:
                    message.isBot = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UserIsBot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_bot = 1; */
        if (message.isBot !== false)
            writer.tag(1, WireType.Varint).bool(message.isBot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UserIsBot
 */
export const Experiment_UserIsBot = new Experiment_UserIsBot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UserAgeRange$Type extends MessageType<Experiment_UserAgeRange> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UserAgeRange", [
            { no: 1, name: "min_age_years", kind: "message", T: () => UInt32Value },
            { no: 2, name: "max_age_years", kind: "message", T: () => UInt32Value }
        ]);
    }
    create(value?: PartialMessage<Experiment_UserAgeRange>): Experiment_UserAgeRange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Experiment_UserAgeRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UserAgeRange): Experiment_UserAgeRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional google.protobuf.UInt32Value min_age_years */ 1:
                    message.minAgeYears = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.minAgeYears);
                    break;
                case /* optional google.protobuf.UInt32Value max_age_years */ 2:
                    message.maxAgeYears = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxAgeYears);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UserAgeRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional google.protobuf.UInt32Value min_age_years = 1; */
        if (message.minAgeYears)
            UInt32Value.internalBinaryWrite(message.minAgeYears, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.UInt32Value max_age_years = 2; */
        if (message.maxAgeYears)
            UInt32Value.internalBinaryWrite(message.maxAgeYears, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UserAgeRange
 */
export const Experiment_UserAgeRange = new Experiment_UserAgeRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Fixed64Value$Type extends MessageType<Experiment_Fixed64Value> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.Fixed64Value", [
            { no: 1, name: "value", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_Fixed64Value>): Experiment_Fixed64Value {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = 0n;
        if (value !== undefined)
            reflectionMergePartial<Experiment_Fixed64Value>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Fixed64Value): Experiment_Fixed64Value {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed64 value */ 1:
                    message.value = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Fixed64Value, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed64 value = 1; */
        if (message.value !== 0n)
            writer.tag(1, WireType.Bit64).fixed64(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.Fixed64Value
 */
export const Experiment_Fixed64Value = new Experiment_Fixed64Value$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UserIDRange$Type extends MessageType<Experiment_UserIDRange> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UserIDRange", [
            { no: 1, name: "min_id", kind: "message", T: () => Experiment_Fixed64Value },
            { no: 2, name: "max_id", kind: "message", T: () => Experiment_Fixed64Value }
        ]);
    }
    create(value?: PartialMessage<Experiment_UserIDRange>): Experiment_UserIDRange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Experiment_UserIDRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UserIDRange): Experiment_UserIDRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional discord_protos.discord_experimentation.v1.Experiment.Fixed64Value min_id */ 1:
                    message.minId = Experiment_Fixed64Value.internalBinaryRead(reader, reader.uint32(), options, message.minId);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.Fixed64Value max_id */ 2:
                    message.maxId = Experiment_Fixed64Value.internalBinaryRead(reader, reader.uint32(), options, message.maxId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UserIDRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional discord_protos.discord_experimentation.v1.Experiment.Fixed64Value min_id = 1; */
        if (message.minId)
            Experiment_Fixed64Value.internalBinaryWrite(message.minId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.Fixed64Value max_id = 2; */
        if (message.maxId)
            Experiment_Fixed64Value.internalBinaryWrite(message.maxId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UserIDRange
 */
export const Experiment_UserIDRange = new Experiment_UserIDRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UserHasFlag$Type extends MessageType<Experiment_UserHasFlag> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UserHasFlag", [
            { no: 1, name: "mask", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_UserHasFlag>): Experiment_UserHasFlag {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mask = 0n;
        if (value !== undefined)
            reflectionMergePartial<Experiment_UserHasFlag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UserHasFlag): Experiment_UserHasFlag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed64 mask */ 1:
                    message.mask = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UserHasFlag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed64 mask = 1; */
        if (message.mask !== 0n)
            writer.tag(1, WireType.Bit64).fixed64(message.mask);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UserHasFlag
 */
export const Experiment_UserHasFlag = new Experiment_UserHasFlag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UnitIdInRangeByHash$Type extends MessageType<Experiment_UnitIdInRangeByHash> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UnitIdInRangeByHash", [
            { no: 1, name: "hash_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_UnitIdInRangeByHash>): Experiment_UnitIdInRangeByHash {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hashKey = "";
        message.target = 0;
        if (value !== undefined)
            reflectionMergePartial<Experiment_UnitIdInRangeByHash>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UnitIdInRangeByHash): Experiment_UnitIdInRangeByHash {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hash_key */ 1:
                    message.hashKey = reader.string();
                    break;
                case /* uint32 target */ 2:
                    message.target = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UnitIdInRangeByHash, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hash_key = 1; */
        if (message.hashKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hashKey);
        /* uint32 target = 2; */
        if (message.target !== 0)
            writer.tag(2, WireType.Varint).uint32(message.target);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UnitIdInRangeByHash
 */
export const Experiment_UnitIdInRangeByHash = new Experiment_UnitIdInRangeByHash$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_ClientReleaseChannel$Type extends MessageType<Experiment_ClientReleaseChannel> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.ClientReleaseChannel", [
            { no: 1, name: "release_channels", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_ClientReleaseChannel>): Experiment_ClientReleaseChannel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.releaseChannels = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_ClientReleaseChannel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_ClientReleaseChannel): Experiment_ClientReleaseChannel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string release_channels = 1 [packed = false] */ 1:
                    message.releaseChannels.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_ClientReleaseChannel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string release_channels = 1 [packed = false]; */
        for (let i = 0; i < message.releaseChannels.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.releaseChannels[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientReleaseChannel
 */
export const Experiment_ClientReleaseChannel = new Experiment_ClientReleaseChannel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Always$Type extends MessageType<Experiment_Always> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.Always", [
            { no: 1, name: "value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_Always>): Experiment_Always {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = false;
        if (value !== undefined)
            reflectionMergePartial<Experiment_Always>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Always): Experiment_Always {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool value */ 1:
                    message.value = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Always, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool value = 1; */
        if (message.value !== false)
            writer.tag(1, WireType.Varint).bool(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.Always
 */
export const Experiment_Always = new Experiment_Always$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Filter$Type extends MessageType<Experiment_Filter> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.Filter", [
            { no: 2, name: "client_version", kind: "message", oneof: "filter", T: () => Experiment_ClientPlatform },
            { no: 3, name: "client_os", kind: "message", oneof: "filter", T: () => Experiment_ClientOperatingSystem },
            { no: 4, name: "staff", kind: "message", oneof: "filter", T: () => Experiment_StaffUsers },
            { no: 5, name: "user_in_guild", kind: "message", oneof: "filter", T: () => Experiment_UserInGuild },
            { no: 6, name: "user_ids", kind: "message", oneof: "filter", T: () => Experiment_UserIds },
            { no: 7, name: "client_locale", kind: "message", oneof: "filter", T: () => Experiment_ClientLocale },
            { no: 8, name: "client_location", kind: "message", oneof: "filter", T: () => Experiment_ClientLocation },
            { no: 9, name: "client_ip", kind: "message", oneof: "filter", T: () => Experiment_ClientIP },
            { no: 10, name: "user_locale", kind: "message", oneof: "filter", T: () => Experiment_UserLocale },
            { no: 11, name: "bot", kind: "message", oneof: "filter", T: () => Experiment_UserIsBot },
            { no: 12, name: "user_age_range", kind: "message", oneof: "filter", T: () => Experiment_UserAgeRange },
            { no: 13, name: "user_id_range", kind: "message", oneof: "filter", T: () => Experiment_UserIDRange },
            { no: 14, name: "user_has_flag", kind: "message", oneof: "filter", T: () => Experiment_UserHasFlag },
            { no: 15, name: "unit_id_in_range_by_hash", kind: "message", oneof: "filter", T: () => Experiment_UnitIdInRangeByHash },
            { no: 16, name: "client_release_channel", kind: "message", oneof: "filter", T: () => Experiment_ClientReleaseChannel },
            { no: 17, name: "always", kind: "message", oneof: "filter", T: () => Experiment_Always }
        ]);
    }
    create(value?: PartialMessage<Experiment_Filter>): Experiment_Filter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filter = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Experiment_Filter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Filter): Experiment_Filter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* discord_protos.discord_experimentation.v1.Experiment.ClientPlatform client_version */ 2:
                    message.filter = {
                        oneofKind: "clientVersion",
                        clientVersion: Experiment_ClientPlatform.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).clientVersion)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.ClientOperatingSystem client_os */ 3:
                    message.filter = {
                        oneofKind: "clientOs",
                        clientOs: Experiment_ClientOperatingSystem.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).clientOs)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.StaffUsers staff */ 4:
                    message.filter = {
                        oneofKind: "staff",
                        staff: Experiment_StaffUsers.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).staff)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UserInGuild user_in_guild */ 5:
                    message.filter = {
                        oneofKind: "userInGuild",
                        userInGuild: Experiment_UserInGuild.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).userInGuild)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UserIds user_ids */ 6:
                    message.filter = {
                        oneofKind: "userIds",
                        userIds: Experiment_UserIds.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).userIds)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.ClientLocale client_locale */ 7:
                    message.filter = {
                        oneofKind: "clientLocale",
                        clientLocale: Experiment_ClientLocale.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).clientLocale)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.ClientLocation client_location */ 8:
                    message.filter = {
                        oneofKind: "clientLocation",
                        clientLocation: Experiment_ClientLocation.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).clientLocation)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.ClientIP client_ip */ 9:
                    message.filter = {
                        oneofKind: "clientIp",
                        clientIp: Experiment_ClientIP.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).clientIp)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UserLocale user_locale */ 10:
                    message.filter = {
                        oneofKind: "userLocale",
                        userLocale: Experiment_UserLocale.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).userLocale)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UserIsBot bot */ 11:
                    message.filter = {
                        oneofKind: "bot",
                        bot: Experiment_UserIsBot.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).bot)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UserAgeRange user_age_range */ 12:
                    message.filter = {
                        oneofKind: "userAgeRange",
                        userAgeRange: Experiment_UserAgeRange.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).userAgeRange)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UserIDRange user_id_range */ 13:
                    message.filter = {
                        oneofKind: "userIdRange",
                        userIdRange: Experiment_UserIDRange.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).userIdRange)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UserHasFlag user_has_flag */ 14:
                    message.filter = {
                        oneofKind: "userHasFlag",
                        userHasFlag: Experiment_UserHasFlag.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).userHasFlag)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UnitIdInRangeByHash unit_id_in_range_by_hash */ 15:
                    message.filter = {
                        oneofKind: "unitIdInRangeByHash",
                        unitIdInRangeByHash: Experiment_UnitIdInRangeByHash.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).unitIdInRangeByHash)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.ClientReleaseChannel client_release_channel */ 16:
                    message.filter = {
                        oneofKind: "clientReleaseChannel",
                        clientReleaseChannel: Experiment_ClientReleaseChannel.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).clientReleaseChannel)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.Always always */ 17:
                    message.filter = {
                        oneofKind: "always",
                        always: Experiment_Always.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).always)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Filter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* discord_protos.discord_experimentation.v1.Experiment.ClientPlatform client_version = 2; */
        if (message.filter.oneofKind === "clientVersion")
            Experiment_ClientPlatform.internalBinaryWrite(message.filter.clientVersion, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.ClientOperatingSystem client_os = 3; */
        if (message.filter.oneofKind === "clientOs")
            Experiment_ClientOperatingSystem.internalBinaryWrite(message.filter.clientOs, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.StaffUsers staff = 4; */
        if (message.filter.oneofKind === "staff")
            Experiment_StaffUsers.internalBinaryWrite(message.filter.staff, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UserInGuild user_in_guild = 5; */
        if (message.filter.oneofKind === "userInGuild")
            Experiment_UserInGuild.internalBinaryWrite(message.filter.userInGuild, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UserIds user_ids = 6; */
        if (message.filter.oneofKind === "userIds")
            Experiment_UserIds.internalBinaryWrite(message.filter.userIds, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.ClientLocale client_locale = 7; */
        if (message.filter.oneofKind === "clientLocale")
            Experiment_ClientLocale.internalBinaryWrite(message.filter.clientLocale, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.ClientLocation client_location = 8; */
        if (message.filter.oneofKind === "clientLocation")
            Experiment_ClientLocation.internalBinaryWrite(message.filter.clientLocation, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.ClientIP client_ip = 9; */
        if (message.filter.oneofKind === "clientIp")
            Experiment_ClientIP.internalBinaryWrite(message.filter.clientIp, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UserLocale user_locale = 10; */
        if (message.filter.oneofKind === "userLocale")
            Experiment_UserLocale.internalBinaryWrite(message.filter.userLocale, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UserIsBot bot = 11; */
        if (message.filter.oneofKind === "bot")
            Experiment_UserIsBot.internalBinaryWrite(message.filter.bot, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UserAgeRange user_age_range = 12; */
        if (message.filter.oneofKind === "userAgeRange")
            Experiment_UserAgeRange.internalBinaryWrite(message.filter.userAgeRange, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UserIDRange user_id_range = 13; */
        if (message.filter.oneofKind === "userIdRange")
            Experiment_UserIDRange.internalBinaryWrite(message.filter.userIdRange, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UserHasFlag user_has_flag = 14; */
        if (message.filter.oneofKind === "userHasFlag")
            Experiment_UserHasFlag.internalBinaryWrite(message.filter.userHasFlag, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UnitIdInRangeByHash unit_id_in_range_by_hash = 15; */
        if (message.filter.oneofKind === "unitIdInRangeByHash")
            Experiment_UnitIdInRangeByHash.internalBinaryWrite(message.filter.unitIdInRangeByHash, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.ClientReleaseChannel client_release_channel = 16; */
        if (message.filter.oneofKind === "clientReleaseChannel")
            Experiment_ClientReleaseChannel.internalBinaryWrite(message.filter.clientReleaseChannel, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.Always always = 17; */
        if (message.filter.oneofKind === "always")
            Experiment_Always.internalBinaryWrite(message.filter.always, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.Filter
 */
export const Experiment_Filter = new Experiment_Filter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Override$Type extends MessageType<Experiment_Override> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.Override", [
            { no: 1, name: "variant_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_Override>): Experiment_Override {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.variantId = 0;
        if (value !== undefined)
            reflectionMergePartial<Experiment_Override>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Override): Experiment_Override {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 variant_id */ 1:
                    message.variantId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Override, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 variant_id = 1; */
        if (message.variantId !== 0)
            writer.tag(1, WireType.Varint).int32(message.variantId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.Override
 */
export const Experiment_Override = new Experiment_Override$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Rule$Type extends MessageType<Experiment_Rule> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.Rule", [
            { no: 1, name: "type", kind: "enum", T: () => ["discord_protos.discord_experimentation.v1.Experiment.Type", Experiment_Type, "TYPE_"] },
            { no: 2, name: "filters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Experiment_Filter },
            { no: 3, name: "override", kind: "message", T: () => Experiment_Override },
            { no: 4, name: "is_sunset_rule", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_Rule>): Experiment_Rule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.filters = [];
        message.isSunsetRule = false;
        if (value !== undefined)
            reflectionMergePartial<Experiment_Rule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Rule): Experiment_Rule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* discord_protos.discord_experimentation.v1.Experiment.Type type */ 1:
                    message.type = reader.int32();
                    break;
                case /* repeated discord_protos.discord_experimentation.v1.Experiment.Filter filters */ 2:
                    message.filters.push(Experiment_Filter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.Override override */ 3:
                    message.override = Experiment_Override.internalBinaryRead(reader, reader.uint32(), options, message.override);
                    break;
                case /* bool is_sunset_rule */ 4:
                    message.isSunsetRule = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Rule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* discord_protos.discord_experimentation.v1.Experiment.Type type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* repeated discord_protos.discord_experimentation.v1.Experiment.Filter filters = 2; */
        for (let i = 0; i < message.filters.length; i++)
            Experiment_Filter.internalBinaryWrite(message.filters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.Override override = 3; */
        if (message.override)
            Experiment_Override.internalBinaryWrite(message.override, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool is_sunset_rule = 4; */
        if (message.isSunsetRule !== false)
            writer.tag(4, WireType.Varint).bool(message.isSunsetRule);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.Rule
 */
export const Experiment_Rule = new Experiment_Rule$Type();
